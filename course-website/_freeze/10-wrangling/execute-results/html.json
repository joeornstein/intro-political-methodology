{
  "hash": "e8b9120a2d642a58e89523ee06250991",
  "result": {
    "markdown": "---\ntitle: \"Week 10: Data Wrangling\"\nauthor: Joe Ornstein\n\necho: true\nmessage: false\nwarning: false\n---\n\n\nUp to now, we've been working with pretty tidy datasets. Every column is a variable, every row is an observation, and every value is where it should be. But things are not always this way. More often than you're going to like, data comes to you an unruly mess, and you'll need to tidy it up before you can even start to explore it.\n\nThis week, we'll learn some of the most important functions in the `tidyverse` for data wrangling. By the end of the week, you will be able to:\n\n-   Filter the rows of a dataset using conditional logic with the `filter()` function\n\n-   Select and rename columns using the `select()` function\n\n-   Create new variables and modify existing ones using the `mutate()` function\n\n-   Properly format categorical variables, with the help of functions like `case_when()` and `factor()`\n\n-   Perform a basic data merge with `left_join()`\n\n# Reading\n\n-   **R4DS** Chapters 3-4\n\n-   **R4DS** Chapter 12\n\n# Problem Set\n\nThis week, we're going to be summarizing different variables from the CES 2020 dataset. You'll need to download the dataset (see instructions in the class notes below) and use the codebook to identify which variables contain the information you want, tidy them up, and then summarize. Write an `R` script that performs these tasks, compile a PDF report, and submit the report.\n\nHere are the questions I'd like you to answer:\n\n1.  Are labor union members more likely to be Democrats or Republicans?\n\n2.  Compare the average age of people with landline phones, compared to those who only have cell phones? Estimate the difference-in-means and report the p-value from a null hypothesis test.\n\n3.  Are people who read the newspaper more likely to correctly answer the questions about who controls the US House of Representatives and US Senate? (Remember, this survey was conducted at the end of 2020.)\n\n4.  Create a bar chart reporting the percent of respondents in each religious group that support making abortion illegal in all circumstances.\n\n5.  **Bonus**. The CES oversamples some respondents relative to their frequency among registered voters in order to get a better statistical picture of some smaller subgroups. The dataset contains a *weight* variable for each respondent, reflecting how much that type of respondent is overrepresented in the sample compared to the population. Compare the mean age of the sample with the *weighted mean* age of the sample. What do you notice? Do the same thing for the unweighted and weighted shares of each racial group. Redo the analyses in questions 1-4 using weighted means. What conclusions, if any, change?\n\n# Class Notes\n\nPreviously, we have worked with a tidied up version of the Cooperative Election Study (CES) from 2020. To illustrate the process of **data wrangling**, let's look at the steps I took to import and clean up that dataset.\n\n[![](img/data_wrangler.png)](https://allisonhorst.shinyapps.io/dplyr-learnr/#section-welcome)\n\n### Importing The Data\n\nThe CES is a survey of a representative sample of 50,000+ American adults, conducted every election year by a large consortium of universities. The data going back to 2006 is available [here](https://cces.gov.harvard.edu/). Go to that site and download the 2020 dataset, a 180 megabyte monster called `CES20_Common_OUTPUT_vv.csv`.\n\nThe `.csv` extension at the end of the file means that it is a \"comma separated value\" file. This is a file where all of the values are separated by commas. Looks something like this:\n\n```         \nname, age, party\n'Joe', 35, 'Bull Moose'\n'Fiona', 6, 'Birthday'\n'Avery', 3, 'Know Nothing'\n```\n\nIt's a nice standardized way to represent datasets, and fortunately for us, the `read_csv()` function allows us to read such files into `R`.[^1] Let's create an object called `ces_raw` from that raw dataset.\n\n[^1]: I will generally use `read_csv()` instead of `read.csv()` in my own work, since it is faster and will give you useful error messages if the input is formatted in a way it doesn't expect.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nces_raw <- read_csv('data/raw/CES20_Common_OUTPUT_vv.csv')\n```\n:::\n\n\nThis dataset has a lot of information.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndim(ces_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 61000   717\n```\n:::\n:::\n\n\n61,000 rows and 717 columns, to be precise. The first few rows and columns look like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ces_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 717\n   ...1     caseid commonweight commonpostweight vvweight vvweight_post tookpost\n  <dbl>      <dbl>        <dbl>            <dbl>    <dbl>         <dbl>    <dbl>\n1     1 1232318697        0.783            0.666    0.851         0.607        2\n2     2 1231394915        1.34             1.44    NA            NA            2\n3     3 1232451503        0.406            0.342   NA            NA            2\n4     4 1232494791        0.958            0.822    1.04          1.00         2\n5     5 1232494829        0.195            0.162   NA            NA            2\n6     6 1232473675        1.06             0.880    1.15          0.988        2\n# ℹ 710 more variables: CCEStake <dbl>, birthyr <dbl>, gender <dbl>,\n#   educ <dbl>, race <dbl>, race_other <chr>, hispanic <dbl>,\n#   CC20_hisp_1 <dbl>, CC20_hisp_2 <dbl>, CC20_hisp_3 <dbl>, CC20_hisp_4 <dbl>,\n#   CC20_hisp_5 <dbl>, CC20_hisp_6 <dbl>, CC20_hisp_7 <dbl>, CC20_hisp_8 <dbl>,\n#   CC20_hisp_9 <dbl>, CC20_hisp_10 <dbl>, CC20_hisp_11 <dbl>,\n#   CC20_hisp_12 <dbl>, CC20_hisp_t <chr>, CC20_asian_1 <dbl>,\n#   CC20_asian_2 <dbl>, CC20_asian_3 <dbl>, CC20_asian_4 <dbl>, …\n```\n:::\n:::\n\n\n### Recoding Variables\n\nNow that we have the dataset loaded into memory, let's find the variables we're interested in keeping and clean them up a bit. For example, gender is coded as a 1 or 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_raw |> \n  count(gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  gender     n\n   <dbl> <int>\n1      1 25791\n2      2 35209\n```\n:::\n:::\n\n\nLet's make this more readable. The codebook (available at the same site where you downloaded the data) says that 1 is male and 2 is female. We can create a new version of the gender column using the `mutate()` and `if_else()` functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_clean <- ces_raw |> \n  mutate(gender = if_else(gender == 1, 'Male', 'Female'))\n\nces_clean |> \n  count(gender)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 2\n  gender     n\n  <chr>  <int>\n1 Female 35209\n2 Male   25791\n```\n:::\n:::\n\n\nWhat about the education variable (`educ`)?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_clean |> \n  count(educ)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n   educ     n\n  <dbl> <int>\n1     1  1983\n2     2 16618\n3     3 13330\n4     4  6539\n5     5 14152\n6     6  8378\n```\n:::\n:::\n\n\nThat's a lot of categories to clean up. We can combine the `mutate()` function with `case_when()` to recode a bunch of different values at the same time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_clean <- ces_clean |> \n  mutate(educ = case_when(educ == 1 ~ 'No HS',\n                          educ == 2 ~ 'High school graduate',\n                          educ == 3 ~ 'Some college',\n                          educ == 4 ~ '2-year',\n                          educ == 5 ~ '4-year',\n                          educ == 6 ~ 'Post-grad'))\nces_clean |> \n  count(educ)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  educ                     n\n  <chr>                <int>\n1 2-year                6539\n2 4-year               14152\n3 High school graduate 16618\n4 No HS                 1983\n5 Post-grad             8378\n6 Some college         13330\n```\n:::\n:::\n\n\nNow the variable has the correct labels, but notice that the order in that table is kind of weird. We tend to think of education as an **ordinal** variable, because there's a natural order from least to most educated. But `R` doesn't know that yet. It just thinks of `educ` as a character variable, and lists them in alphabetical order. We can tell `R` about the variable order by recoding `educ` as a **factor**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_clean <- ces_clean |> \n  mutate(educ = factor(educ,\n                       levels = c('No HS', \n                                  'High school graduate',\n                                  'Some college',\n                                  '2-year',\n                                  '4-year',\n                                  'Post-grad')))\nces_clean |> \n  count(educ)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  educ                     n\n  <fct>                <int>\n1 No HS                 1983\n2 High school graduate 16618\n3 Some college         13330\n4 2-year                6539\n5 4-year               14152\n6 Post-grad             8378\n```\n:::\n:::\n\n\nMuch better!\n\nThere's a variable in CES called `birthyr`. What if we wanted to know the respondents age in 2020 instead? The `mutate()` function can help us here too.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_clean |> \n  count(birthyr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 78 × 2\n   birthyr     n\n     <dbl> <int>\n 1    1925     2\n 2    1926     6\n 3    1927    10\n 4    1928    12\n 5    1929    23\n 6    1930    23\n 7    1931    42\n 8    1932    55\n 9    1933    76\n10    1934   109\n# ℹ 68 more rows\n```\n:::\n\n```{.r .cell-code}\nces_clean <- ces_clean |> \n  mutate(age = 2020 - birthyr)\n\nces_clean |> \n  count(birthyr, age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 78 × 3\n   birthyr   age     n\n     <dbl> <dbl> <int>\n 1    1925    95     2\n 2    1926    94     6\n 3    1927    93    10\n 4    1928    92    12\n 5    1929    91    23\n 6    1930    90    23\n 7    1931    89    42\n 8    1932    88    55\n 9    1933    87    76\n10    1934    86   109\n# ℹ 68 more rows\n```\n:::\n:::\n\n\n### Joining Datasets\n\nHere's another messy feature of this dataset. Every respondent has a variable called `inputstate`, representing the state where they live.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_clean |> \n  count(inputstate)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 51 × 2\n   inputstate     n\n        <dbl> <int>\n 1          1   947\n 2          2   115\n 3          4  1463\n 4          5   536\n 5          6  5035\n 6          8  1061\n 7          9   642\n 8         10   240\n 9         11   197\n10         12  4615\n# ℹ 41 more rows\n```\n:::\n:::\n\n\nBut it's a number! Not, like, the actual name of the state, which would be more useful to me. I don't know all 51 state [FIPS codes](https://www.nrcs.usda.gov/wps/portal/nrcs/detail/?cid=nrcs143_013696) by heart, but fortunately I have a dataset that includes every state's name and FIPS code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstate_fips <- tidycensus::fips_codes |> \n  mutate(inputstate = as.numeric(state_code)) |> \n  select(inputstate, state_name) |> \n  unique()\n\nhead(state_fips)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    inputstate state_name\n1            1    Alabama\n68           2     Alaska\n97           4    Arizona\n112          5   Arkansas\n187          6 California\n245          8   Colorado\n```\n:::\n:::\n\n\nAnd I can **join** that information with the CES data like this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_clean <- ces_clean |> \n  left_join(state_fips, by = 'inputstate')\n\nces_clean |> \n  count(inputstate, state_name)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 51 × 3\n   inputstate state_name               n\n        <dbl> <chr>                <int>\n 1          1 Alabama                947\n 2          2 Alaska                 115\n 3          4 Arizona               1463\n 4          5 Arkansas               536\n 5          6 California            5035\n 6          8 Colorado              1061\n 7          9 Connecticut            642\n 8         10 Delaware               240\n 9         11 District of Columbia   197\n10         12 Florida               4615\n# ℹ 41 more rows\n```\n:::\n:::\n\n\nWe will explore joining datasets more deeply in two weeks.\n\n### Selecting Variables\n\nFinally, we can use the `select()` function to keep only the columns we want, and drop the columns we don't want.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nces_clean <- ces_clean |> \n  select(caseid, gender, educ, age, state_name)\n\nhead(ces_clean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n      caseid gender educ           age state_name   \n       <dbl> <chr>  <fct>        <dbl> <chr>        \n1 1232318697 Male   2-year          54 Connecticut  \n2 1231394915 Female Post-grad       65 Florida      \n3 1232451503 Female 4-year          74 Iowa         \n4 1232494791 Female 4-year          58 Massachusetts\n5 1232494829 Male   4-year          53 Illinois     \n6 1232473675 Male   Some college    59 Ohio         \n```\n:::\n:::\n\n\nAnd you can save your cleaned up version of the data to an .RData file with the `save()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsave(ces_clean, file = 'data/ces-clean.RData')\n```\n:::\n\n\n# Additional Resources\n\n-   [Wrangling Penguins](https://allisonhorst.shinyapps.io/dplyr-learnr/#section-welcome), by Allison Horst\n",
    "supporting": [
      "10-wrangling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}